{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"topsecret","text":"<p><code>top secret</code> is an encryption and decryption service with a REST API.</p> <p>It provides two primary methods of encryption:</p> <ol> <li>Auto encryption: Generates keys automatically and stores them securely</li> <li>Passphrase encryption: Uses a user-provided passphrase for more secure encryption</li> </ol> <p>The project includes a FastAPI web service that expose encryption functionality through HTTP endpoints, allowing users to encrypt sensitive information and share decryption URLs.</p>"},{"location":"#sponsorship","title":"Sponsorship","text":"<p>A special thanks to Hamkee for sponsoring the project and providing hosting services.</p> <p>If you find this project useful, consider supporting its development: </p>"},{"location":"#run-api-on-three-simple-steps","title":"Run API on three simple steps","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher and <code>make</code> installed.</li> </ul> <p>1- Install <code>uv</code> (Linux and MacOS)</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>2- Run <code>make install</code> to install dependencies.</p> <pre><code>make install\n</code></pre> <p>3- Run <code>make run</code> to start the API server.</p> <pre><code>make run\n</code></pre>"},{"location":"domain/","title":"Secrets","text":"<p>Domain layer is the core of the application. It contains interfaces and business logic. It is independent of any framework or technology. It should not depend on any other layer. It should only depend on the entities and value objects. </p>"},{"location":"domain/#topsecret.domain.CipherProtocol","title":"<code>CipherProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines a protocol for cryptographic operations, specifically encrypting and decrypting byte data.</p> <p>This protocol outlines the contract for classes that provide encryption and decryption functionalities. Implementations are expected to handle the conversion of plaintext data into a secure, encrypted format (ciphertext) and vice-versa. The protocol supports operations with an optional passphrase, allowing for both passphrase-based encryption and potentially other key management schemes.</p> <p>The <code>Ciphertext</code> and <code>Metadata</code> types mentioned in method signatures are placeholders for the specific types that an implementing class would use for encrypted data and its associated metadata, respectively.</p> <p>Attributes:</p> Name Type Description <code>AUTO_KEY_SEP</code> <code>bytes</code> <p>A class-level constant representing a byte sequence (b\"|\"). This separator is intended for use in \"auto encryption\" scenarios. While the specific mechanism of \"auto encryption\" is not defined by this protocol, this separator likely plays a role in demarcating or structuring data when keys are managed automatically or embedded within the ciphertext or metadata.</p> Source code in <code>topsecret/domain.py</code> <pre><code>class CipherProtocol(t.Protocol):\n    \"\"\"Defines a protocol for cryptographic operations, specifically encrypting and\n    decrypting byte data.\n\n    This protocol outlines the contract for classes that provide encryption and\n    decryption functionalities. Implementations are expected to handle the\n    conversion of plaintext data into a secure, encrypted format (ciphertext)\n    and vice-versa. The protocol supports operations with an optional passphrase,\n    allowing for both passphrase-based encryption and potentially other key\n    management schemes.\n\n    The `Ciphertext` and `Metadata` types mentioned in method signatures are\n    placeholders for the specific types that an implementing class would use for\n    encrypted data and its associated metadata, respectively.\n\n    Attributes:\n        AUTO_KEY_SEP (bytes): A class-level constant representing a byte sequence\n            (b\"|\"). This separator is intended for use in \"auto encryption\"\n            scenarios. While the specific mechanism of \"auto encryption\" is not\n            defined by this protocol, this separator likely plays a role in\n            demarcating or structuring data when keys are managed automatically\n            or embedded within the ciphertext or metadata.\n    \"\"\"\n\n    \"\"\"Encrypt/Decrypt bytes.\"\"\"\n\n    AUTO_KEY_SEP: bytes = b\"|\"  # for auto encryption\n\n    def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Metadata]:\n        \"\"\"Encrypts the provided byte data.\n\n        This method takes raw byte data and an optional passphrase, processes it\n        through an encryption algorithm, and returns the resulting ciphertext\n        along with associated metadata. The metadata is crucial as it may contain\n        information required for successful decryption, such as initialization\n        vectors (IVs), salts, or parameters related to the encryption algorithm\n        or key derivation.\n\n        If a passphrase is not provided, the implementation is expected to handle\n        key management. This could involve generating a new key, using a\n        pre-configured key, or employing a mechanism related to \"auto encryption\"\n        (potentially using `AUTO_KEY_SEP`). The specifics of this behavior are\n        left to the implementing class.\n\n        Args:\n            data (bytes): The raw byte data to be encrypted.\n            passphrase (str | None): An optional passphrase to be used for deriving\n                the encryption key. If None, the encryption method should define\n                its behavior for key generation or retrieval according to its\n                key management strategy.\n\n        Returns:\n            tuple[Ciphertext, Metadata]: A tuple containing two elements:\n                - Ciphertext: The encrypted version of the input `data`. The exact\n                type or structure of `Ciphertext` is not defined by this protocol\n                but is expected to be the encrypted payload.\n                - Metadata: Ancillary information required or useful for the\n                decryption process. This could include salts, IVs, algorithm\n                identifiers, or other cryptographic parameters. The exact type\n                or structure of `Metadata` is also implementation-dependent.\n        \"\"\"\n        ...\n\n    def decrypt(self, ciphertext: Ciphertext, metadata: Metadata, passphrase: str | None = None) -&gt; str:\n        \"\"\"Decrypts the given ciphertext back into its original string form.\n\n        This method takes ciphertext and its associated metadata, along with an\n        optional passphrase, to reverse the encryption process. It attempts to\n        decrypt the data and then decodes the resulting bytes into a string.\n        The successful execution of this method relies on the correct ciphertext,\n        metadata, and, if used during encryption, the correct passphrase.\n\n        The metadata provided must correspond to the metadata generated during the\n        encryption of the `ciphertext`. If a passphrase was used for encryption,\n        the same passphrase must be provided for decryption. If no passphrase was\n        used (e.g., in an \"auto encryption\" scenario where the key is managed\n        differently), providing `None` for the passphrase argument should allow\n        the decryption process to proceed using the implementation's key management\n        strategy.\n\n        The return type of `str` implies that the original data, before encryption,\n        was text that was encoded into bytes (e.g., using UTF-8) and, upon\n        decryption, is decoded back into a string using an appropriate encoding\n        assumed by the implementation.\n\n        Args:\n            ciphertext (Ciphertext): The encrypted data to be decrypted. This should\n                be the `Ciphertext` object obtained from a compatible `encrypt` method.\n            metadata (Metadata): The metadata associated with the `ciphertext`. This\n                should be the `Metadata` object obtained from a compatible `encrypt`\n                method, containing all necessary information for decryption.\n            passphrase (str | None): The passphrase that was used to encrypt the\n                data. If no passphrase was used during encryption (e.g., key was\n                auto-generated and managed), this should be `None`.\n\n        Returns:\n            str: The decrypted data, decoded into a string.\n\n        Raises:\n            Exception: While not explicitly defined in the protocol, implementations\n                are expected to raise an appropriate exception (e.g., a custom\n                `DecryptionError`, `ValueError`, or a cryptography-specific error)\n                if the decryption fails. This could be due to an incorrect\n                passphrase, corrupted data, tampered ciphertext/metadata, or\n                mismatched cryptographic parameters.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherProtocol.decrypt","title":"<code>decrypt(ciphertext, metadata, passphrase=None)</code>","text":"<p>Decrypts the given ciphertext back into its original string form.</p> <p>This method takes ciphertext and its associated metadata, along with an optional passphrase, to reverse the encryption process. It attempts to decrypt the data and then decodes the resulting bytes into a string. The successful execution of this method relies on the correct ciphertext, metadata, and, if used during encryption, the correct passphrase.</p> <p>The metadata provided must correspond to the metadata generated during the encryption of the <code>ciphertext</code>. If a passphrase was used for encryption, the same passphrase must be provided for decryption. If no passphrase was used (e.g., in an \"auto encryption\" scenario where the key is managed differently), providing <code>None</code> for the passphrase argument should allow the decryption process to proceed using the implementation's key management strategy.</p> <p>The return type of <code>str</code> implies that the original data, before encryption, was text that was encoded into bytes (e.g., using UTF-8) and, upon decryption, is decoded back into a string using an appropriate encoding assumed by the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>Ciphertext</code> <p>The encrypted data to be decrypted. This should be the <code>Ciphertext</code> object obtained from a compatible <code>encrypt</code> method.</p> required <code>metadata</code> <code>Metadata</code> <p>The metadata associated with the <code>ciphertext</code>. This should be the <code>Metadata</code> object obtained from a compatible <code>encrypt</code> method, containing all necessary information for decryption.</p> required <code>passphrase</code> <code>str | None</code> <p>The passphrase that was used to encrypt the data. If no passphrase was used during encryption (e.g., key was auto-generated and managed), this should be <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decrypted data, decoded into a string.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>While not explicitly defined in the protocol, implementations are expected to raise an appropriate exception (e.g., a custom <code>DecryptionError</code>, <code>ValueError</code>, or a cryptography-specific error) if the decryption fails. This could be due to an incorrect passphrase, corrupted data, tampered ciphertext/metadata, or mismatched cryptographic parameters.</p> Source code in <code>topsecret/domain.py</code> <pre><code>def decrypt(self, ciphertext: Ciphertext, metadata: Metadata, passphrase: str | None = None) -&gt; str:\n    \"\"\"Decrypts the given ciphertext back into its original string form.\n\n    This method takes ciphertext and its associated metadata, along with an\n    optional passphrase, to reverse the encryption process. It attempts to\n    decrypt the data and then decodes the resulting bytes into a string.\n    The successful execution of this method relies on the correct ciphertext,\n    metadata, and, if used during encryption, the correct passphrase.\n\n    The metadata provided must correspond to the metadata generated during the\n    encryption of the `ciphertext`. If a passphrase was used for encryption,\n    the same passphrase must be provided for decryption. If no passphrase was\n    used (e.g., in an \"auto encryption\" scenario where the key is managed\n    differently), providing `None` for the passphrase argument should allow\n    the decryption process to proceed using the implementation's key management\n    strategy.\n\n    The return type of `str` implies that the original data, before encryption,\n    was text that was encoded into bytes (e.g., using UTF-8) and, upon\n    decryption, is decoded back into a string using an appropriate encoding\n    assumed by the implementation.\n\n    Args:\n        ciphertext (Ciphertext): The encrypted data to be decrypted. This should\n            be the `Ciphertext` object obtained from a compatible `encrypt` method.\n        metadata (Metadata): The metadata associated with the `ciphertext`. This\n            should be the `Metadata` object obtained from a compatible `encrypt`\n            method, containing all necessary information for decryption.\n        passphrase (str | None): The passphrase that was used to encrypt the\n            data. If no passphrase was used during encryption (e.g., key was\n            auto-generated and managed), this should be `None`.\n\n    Returns:\n        str: The decrypted data, decoded into a string.\n\n    Raises:\n        Exception: While not explicitly defined in the protocol, implementations\n            are expected to raise an appropriate exception (e.g., a custom\n            `DecryptionError`, `ValueError`, or a cryptography-specific error)\n            if the decryption fails. This could be due to an incorrect\n            passphrase, corrupted data, tampered ciphertext/metadata, or\n            mismatched cryptographic parameters.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherProtocol.encrypt","title":"<code>encrypt(data, passphrase=None)</code>","text":"<p>Encrypts the provided byte data.</p> <p>This method takes raw byte data and an optional passphrase, processes it through an encryption algorithm, and returns the resulting ciphertext along with associated metadata. The metadata is crucial as it may contain information required for successful decryption, such as initialization vectors (IVs), salts, or parameters related to the encryption algorithm or key derivation.</p> <p>If a passphrase is not provided, the implementation is expected to handle key management. This could involve generating a new key, using a pre-configured key, or employing a mechanism related to \"auto encryption\" (potentially using <code>AUTO_KEY_SEP</code>). The specifics of this behavior are left to the implementing class.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The raw byte data to be encrypted.</p> required <code>passphrase</code> <code>str | None</code> <p>An optional passphrase to be used for deriving the encryption key. If None, the encryption method should define its behavior for key generation or retrieval according to its key management strategy.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Ciphertext, Metadata]</code> <p>tuple[Ciphertext, Metadata]: A tuple containing two elements: - Ciphertext: The encrypted version of the input <code>data</code>. The exact type or structure of <code>Ciphertext</code> is not defined by this protocol but is expected to be the encrypted payload. - Metadata: Ancillary information required or useful for the decryption process. This could include salts, IVs, algorithm identifiers, or other cryptographic parameters. The exact type or structure of <code>Metadata</code> is also implementation-dependent.</p> Source code in <code>topsecret/domain.py</code> <pre><code>def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Metadata]:\n    \"\"\"Encrypts the provided byte data.\n\n    This method takes raw byte data and an optional passphrase, processes it\n    through an encryption algorithm, and returns the resulting ciphertext\n    along with associated metadata. The metadata is crucial as it may contain\n    information required for successful decryption, such as initialization\n    vectors (IVs), salts, or parameters related to the encryption algorithm\n    or key derivation.\n\n    If a passphrase is not provided, the implementation is expected to handle\n    key management. This could involve generating a new key, using a\n    pre-configured key, or employing a mechanism related to \"auto encryption\"\n    (potentially using `AUTO_KEY_SEP`). The specifics of this behavior are\n    left to the implementing class.\n\n    Args:\n        data (bytes): The raw byte data to be encrypted.\n        passphrase (str | None): An optional passphrase to be used for deriving\n            the encryption key. If None, the encryption method should define\n            its behavior for key generation or retrieval according to its\n            key management strategy.\n\n    Returns:\n        tuple[Ciphertext, Metadata]: A tuple containing two elements:\n            - Ciphertext: The encrypted version of the input `data`. The exact\n            type or structure of `Ciphertext` is not defined by this protocol\n            but is expected to be the encrypted payload.\n            - Metadata: Ancillary information required or useful for the\n            decryption process. This could include salts, IVs, algorithm\n            identifiers, or other cryptographic parameters. The exact type\n            or structure of `Metadata` is also implementation-dependent.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherStorageProtocol","title":"<code>CipherStorageProtocol</code>","text":"<p>               Bases: <code>Generic[K, V]</code>, <code>Protocol</code></p> <p>Protocol for a generic key-value storage mechanism.</p> <p>This class defines a protocol that specifies an interface for storing, retrieving, and checking the existence of key-value pairs. It is designed to be generic, utilizing type variables <code>K</code> for keys and <code>V</code> for values. This allows concrete implementations to define the specific types they handle, promoting flexibility and type safety.</p> <p>The primary purpose of this protocol is to abstract the underlying storage mechanism. Implementers could use various backends, such as in-memory dictionaries for testing, databases for persistent storage, or distributed caches for scalable solutions. By adhering to this protocol, different storage implementations can be used interchangeably within an application.</p> <p>In the context of cipher management or secure data handling (as suggested by the name \"CipherStorageProtocol\"), <code>K</code> might represent a unique identifier for a cryptographic key, a cipher suite, or a protected data entry. <code>V</code> could then be the actual cryptographic material (e.g., an encryption key, a PGP key object), a configuration object for a cipher, or the encrypted data itself.</p> <p>Implementations are expected to provide the logic for: - <code>retrieve(key)</code>: Fetching a value given its key. - <code>store(key, value)</code>: Persisting a key-value pair. - <code>contains(key)</code>: Verifying if a key is present in the storage.</p> <p>Parameters:</p> Name Type Description Default <code>K</code> <p>TypeVar representing the type of the keys in the storage. This allows for flexibility in choosing key types, such as strings, integers, or custom hashable objects.</p> required <code>V</code> <p>TypeVar representing the type of the values in the storage. This allows for storing various kinds of data, from simple types to complex objects or serialized data.</p> required Source code in <code>topsecret/domain.py</code> <pre><code>class CipherStorageProtocol(t.Generic[K, V], t.Protocol):\n    \"\"\"Protocol for a generic key-value storage mechanism.\n\n    This class defines a protocol that specifies an interface for\n    storing, retrieving, and checking the existence of key-value pairs. It is\n    designed to be generic, utilizing type variables `K` for keys and `V` for\n    values. This allows concrete implementations to define the specific types\n    they handle, promoting flexibility and type safety.\n\n    The primary purpose of this protocol is to abstract the underlying storage\n    mechanism. Implementers could use various backends, such as in-memory\n    dictionaries for testing, databases for persistent storage, or distributed\n    caches for scalable solutions. By adhering to this protocol, different\n    storage implementations can be used interchangeably within an application.\n\n    In the context of cipher management or secure data handling (as suggested by\n    the name \"CipherStorageProtocol\"), `K` might represent a unique identifier\n    for a cryptographic key, a cipher suite, or a protected data entry. `V`\n    could then be the actual cryptographic material (e.g., an encryption key,\n    a PGP key object), a configuration object for a cipher, or the encrypted\n    data itself.\n\n    Implementations are expected to provide the logic for:\n    - `retrieve(key)`: Fetching a value given its key.\n    - `store(key, value)`: Persisting a key-value pair.\n    - `contains(key)`: Verifying if a key is present in the storage.\n\n    Args:\n        K: TypeVar representing the type of the keys in the storage. This allows\n            for flexibility in choosing key types, such as strings, integers, or\n            custom hashable objects.\n        V: TypeVar representing the type of the values in the storage. This allows\n            for storing various kinds of data, from simple types to complex objects\n            or serialized data.\n    \"\"\"\n\n    def retrieve(self, key: K) -&gt; V | None:\n        \"\"\"Retrieves the value associated with the given key.\n\n        This method attempts to find an entry in the storage that matches the\n        provided key. If a corresponding value exists, it is returned. If the\n        key is not found in the storage, this method must return `None`.\n        This explicit `None` return for non-existent keys allows callers to\n        reliably distinguish between a key not being found and a key being\n        associated with a `None` value (if `V` itself can be `NoneType`).\n\n        Args:\n            key (K): The key whose associated value is to be retrieved. The type\n                of the key must match the generic type `K` defined by the\n                implementing class.\n\n        Returns:\n            V | None: The value associated with the specified `key` if it exists\n                within the storage. Returns `None` if the `key` is not found.\n        \"\"\"\n        ...\n\n    def store(self, key: K, value: V) -&gt; None:\n        \"\"\"Stores a key-value pair in the storage.\n\n        This method is responsible for persisting the given `value` under the\n        specified `key`. If the `key` already exists in the storage, the\n        behavior (e.g., overwrite the existing value, raise an error, or ignore\n        the operation) is typically defined by the concrete implementation of\n        this protocol. However, a common expectation for key-value stores is\n        that the new value will replace any existing value for that key.\n\n        The method is expected to complete the storage operation and ensure the\n        key-value pair is durably or appropriately stored according to the\n        implementation's guarantees.\n\n        Args:\n            key (K): The key under which the `value` is to be stored. Its type\n                must conform to the generic type `K` of the protocol.\n            value (V): The value to be stored. Its type must conform to the\n                generic type `V` of the protocol.\n\n        Returns:\n            None: This method does not return any value.\n        \"\"\"\n        ...\n\n    def contains(self, key: K) -&gt; bool:\n        \"\"\"Checks if a key exists in the storage.\n\n        This method determines whether the storage holds any value associated\n        with the given `key`. It provides an efficient way to query the\n        existence of a key without incurring the potential overhead of\n        retrieving the actual value (as the `retrieve` method would do).\n\n        This is particularly useful for pre-flight checks before attempting\n        a `retrieve` or `store` operation (e.g., to decide whether to update\n        or insert), or for any logic that depends on the presence or absence\n        of a key.\n\n        Args:\n            key (K): The key to check for existence in the storage. Its type\n                must conform to the generic type `K` of the protocol.\n\n        Returns:\n            bool: `True` if the `key` is found in the storage, `False` otherwise.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherStorageProtocol.contains","title":"<code>contains(key)</code>","text":"<p>Checks if a key exists in the storage.</p> <p>This method determines whether the storage holds any value associated with the given <code>key</code>. It provides an efficient way to query the existence of a key without incurring the potential overhead of retrieving the actual value (as the <code>retrieve</code> method would do).</p> <p>This is particularly useful for pre-flight checks before attempting a <code>retrieve</code> or <code>store</code> operation (e.g., to decide whether to update or insert), or for any logic that depends on the presence or absence of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to check for existence in the storage. Its type must conform to the generic type <code>K</code> of the protocol.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>key</code> is found in the storage, <code>False</code> otherwise.</p> Source code in <code>topsecret/domain.py</code> <pre><code>def contains(self, key: K) -&gt; bool:\n    \"\"\"Checks if a key exists in the storage.\n\n    This method determines whether the storage holds any value associated\n    with the given `key`. It provides an efficient way to query the\n    existence of a key without incurring the potential overhead of\n    retrieving the actual value (as the `retrieve` method would do).\n\n    This is particularly useful for pre-flight checks before attempting\n    a `retrieve` or `store` operation (e.g., to decide whether to update\n    or insert), or for any logic that depends on the presence or absence\n    of a key.\n\n    Args:\n        key (K): The key to check for existence in the storage. Its type\n            must conform to the generic type `K` of the protocol.\n\n    Returns:\n        bool: `True` if the `key` is found in the storage, `False` otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherStorageProtocol.retrieve","title":"<code>retrieve(key)</code>","text":"<p>Retrieves the value associated with the given key.</p> <p>This method attempts to find an entry in the storage that matches the provided key. If a corresponding value exists, it is returned. If the key is not found in the storage, this method must return <code>None</code>. This explicit <code>None</code> return for non-existent keys allows callers to reliably distinguish between a key not being found and a key being associated with a <code>None</code> value (if <code>V</code> itself can be <code>NoneType</code>).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key whose associated value is to be retrieved. The type of the key must match the generic type <code>K</code> defined by the implementing class.</p> required <p>Returns:</p> Type Description <code>V | None</code> <p>V | None: The value associated with the specified <code>key</code> if it exists within the storage. Returns <code>None</code> if the <code>key</code> is not found.</p> Source code in <code>topsecret/domain.py</code> <pre><code>def retrieve(self, key: K) -&gt; V | None:\n    \"\"\"Retrieves the value associated with the given key.\n\n    This method attempts to find an entry in the storage that matches the\n    provided key. If a corresponding value exists, it is returned. If the\n    key is not found in the storage, this method must return `None`.\n    This explicit `None` return for non-existent keys allows callers to\n    reliably distinguish between a key not being found and a key being\n    associated with a `None` value (if `V` itself can be `NoneType`).\n\n    Args:\n        key (K): The key whose associated value is to be retrieved. The type\n            of the key must match the generic type `K` defined by the\n            implementing class.\n\n    Returns:\n        V | None: The value associated with the specified `key` if it exists\n            within the storage. Returns `None` if the `key` is not found.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"domain/#topsecret.domain.CipherStorageProtocol.store","title":"<code>store(key, value)</code>","text":"<p>Stores a key-value pair in the storage.</p> <p>This method is responsible for persisting the given <code>value</code> under the specified <code>key</code>. If the <code>key</code> already exists in the storage, the behavior (e.g., overwrite the existing value, raise an error, or ignore the operation) is typically defined by the concrete implementation of this protocol. However, a common expectation for key-value stores is that the new value will replace any existing value for that key.</p> <p>The method is expected to complete the storage operation and ensure the key-value pair is durably or appropriately stored according to the implementation's guarantees.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key under which the <code>value</code> is to be stored. Its type must conform to the generic type <code>K</code> of the protocol.</p> required <code>value</code> <code>V</code> <p>The value to be stored. Its type must conform to the generic type <code>V</code> of the protocol.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return any value.</p> Source code in <code>topsecret/domain.py</code> <pre><code>def store(self, key: K, value: V) -&gt; None:\n    \"\"\"Stores a key-value pair in the storage.\n\n    This method is responsible for persisting the given `value` under the\n    specified `key`. If the `key` already exists in the storage, the\n    behavior (e.g., overwrite the existing value, raise an error, or ignore\n    the operation) is typically defined by the concrete implementation of\n    this protocol. However, a common expectation for key-value stores is\n    that the new value will replace any existing value for that key.\n\n    The method is expected to complete the storage operation and ensure the\n    key-value pair is durably or appropriately stored according to the\n    implementation's guarantees.\n\n    Args:\n        key (K): The key under which the `value` is to be stored. Its type\n            must conform to the generic type `K` of the protocol.\n        value (V): The value to be stored. Its type must conform to the\n            generic type `V` of the protocol.\n\n    Returns:\n        None: This method does not return any value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"domain/#topsecret.domain.DecryptionError","title":"<code>DecryptionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception raised when decryption fails.</p> <p>This exception is typically raised when an attempt to decrypt data does not succeed. This can occur for several reasons, such as:     1. The provided passphrase or key is incorrect.     2. The ciphertext has been tampered with or is corrupted.     3. The encryption algorithm or mode of operation used during encryption        is different from what is being used for decryption.     4. The ciphertext is not in the expected format.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>A human-readable string describing the error. If no message is provided during instantiation, a default message is used.</p> Source code in <code>topsecret/domain.py</code> <pre><code>class DecryptionError(Exception):\n    \"\"\"Custom exception raised when decryption fails.\n\n    This exception is typically raised when an attempt to decrypt data does not\n    succeed. This can occur for several reasons, such as:\n        1. The provided passphrase or key is incorrect.\n        2. The ciphertext has been tampered with or is corrupted.\n        3. The encryption algorithm or mode of operation used during encryption\n           is different from what is being used for decryption.\n        4. The ciphertext is not in the expected format.\n\n    Attributes:\n        message (str): A human-readable string describing the error.\n            If no message is provided during instantiation, a default\n            message is used.\n    \"\"\"\n\n    def __init__(self, message: str = \"\"):\n        \"\"\"Initializes a new DecryptionError instance.\n\n        Args:\n            message (str, optional): A custom message describing the specific\n                decryption error. If an empty string or no message is provided,\n                a default error message \"Failed to decrypt the data. The\n                ciphertext may be corrupted or the passphrase is incorrect.\"\n                will be used. This allows for more specific error reporting\n                when the cause of the decryption failure is known, while\n                providing a generic message otherwise.\n        \"\"\"\n        default = \"Failed to decrypt the data. The ciphertext may be corrupted or the passphrase is incorrect.\"\n        super().__init__(message or default)\n</code></pre>"},{"location":"domain/#topsecret.domain.DecryptionError.__init__","title":"<code>__init__(message='')</code>","text":"<p>Initializes a new DecryptionError instance.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A custom message describing the specific decryption error. If an empty string or no message is provided, a default error message \"Failed to decrypt the data. The ciphertext may be corrupted or the passphrase is incorrect.\" will be used. This allows for more specific error reporting when the cause of the decryption failure is known, while providing a generic message otherwise.</p> <code>''</code> Source code in <code>topsecret/domain.py</code> <pre><code>def __init__(self, message: str = \"\"):\n    \"\"\"Initializes a new DecryptionError instance.\n\n    Args:\n        message (str, optional): A custom message describing the specific\n            decryption error. If an empty string or no message is provided,\n            a default error message \"Failed to decrypt the data. The\n            ciphertext may be corrupted or the passphrase is incorrect.\"\n            will be used. This allows for more specific error reporting\n            when the cause of the decryption failure is known, while\n            providing a generic message otherwise.\n    \"\"\"\n    default = \"Failed to decrypt the data. The ciphertext may be corrupted or the passphrase is incorrect.\"\n    super().__init__(message or default)\n</code></pre>"},{"location":"adapters/webapi/","title":"Rest API","text":"<p>WebAPI Adapter is a component that expose the functionality of the TopSecret application through a web API. It allows external systems to interact with the application using standard HTTP methods. </p>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.DecryptRequest","title":"<code>DecryptRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for decryption.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>class DecryptRequest(BaseModel):\n    \"\"\"Request model for decryption.\"\"\"\n\n    passphrase: str | None = Field(None, description=\"Optional passphrase for decryption\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.DecryptResponse","title":"<code>DecryptResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for decryption.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>class DecryptResponse(BaseModel):\n    \"\"\"Response model for decryption.\"\"\"\n\n    secret: str = Field(..., description=\"The decrypted secret\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.EncryptRequest","title":"<code>EncryptRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for encryption.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>class EncryptRequest(BaseModel):\n    \"\"\"Request model for encryption.\"\"\"\n\n    secret: str = Field(..., min_length=1, description=\"The secret text to encrypt\")\n    passphrase: str | None = Field(None, description=\"Optional passphrase for encryption\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.EncryptResponse","title":"<code>EncryptResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for encryption.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>class EncryptResponse(BaseModel):\n    \"\"\"Response model for encryption.\"\"\"\n\n    hash: str = Field(..., description=\"The hash value of the encrypted secret\")\n    decrypt_url: str = Field(..., description=\"The URL to decrypt this secret\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.api_info","title":"<code>api_info()</code>  <code>async</code>","text":"<p>Return API information.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>@api.get(\"/api/info\", tags=[\"info\"])\nasync def api_info() -&gt; dict:\n    \"\"\"Return API information.\"\"\"\n    return {\n        \"name\": \"TopSecret Encryptor API\",\n        \"version\": \"1.0.0\",\n        \"endpoints\": {\"encrypt\": \"/encrypt\", \"decrypt\": \"/decrypt/{hash}\"},\n    }\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.decrypt_secret","title":"<code>decrypt_secret(hash_value, request=Body(default=None))</code>  <code>async</code>","text":"<p>Decrypt a secret given its hash value.</p> <p>This endpoint attempts to decrypt a secret identified by its hash. An optional passphrase can be provided in the request body. Args:     hash_value: The hash identifier of the secret to be decrypted.     request: An optional request body containing the passphrase.             If not provided or if <code>passphrase</code> is None, decryption             will be attempted without a passphrase. Returns:     A DecryptResponse object containing the decrypted secret text. Raises:     HTTPException: If decryption fails (e.g., due to an incorrect                 passphrase or invalid hash), an HTTP 401 Unauthorized                 error is raised with details of the decryption error.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>@api.post(\"/decrypt/{hash_value}\", response_model=DecryptResponse, tags=[\"decryption\"])\nasync def decrypt_secret(hash_value: str, request: DecryptRequest = Body(default=None)) -&gt; DecryptResponse:\n    \"\"\"Decrypt a secret given its hash value.\n\n    This endpoint attempts to decrypt a secret identified by its hash.\n    An optional passphrase can be provided in the request body.\n    Args:\n        hash_value: The hash identifier of the secret to be decrypted.\n        request: An optional request body containing the passphrase.\n                If not provided or if `passphrase` is None, decryption\n                will be attempted without a passphrase.\n    Returns:\n        A DecryptResponse object containing the decrypted secret text.\n    Raises:\n        HTTPException: If decryption fails (e.g., due to an incorrect\n                    passphrase or invalid hash), an HTTP 401 Unauthorized\n                    error is raised with details of the decryption error.\n    \"\"\"\n    passphrase = None if request is None else request.passphrase\n\n    try:\n        decrypted_text = app.encryption_service.decrypt(hash_value, passphrase)\n        return DecryptResponse(secret=decrypted_text)\n    except DecryptionError as e:\n        raise HTTPException(status_code=401, detail=str(e)) from e\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.encrypt_secret","title":"<code>encrypt_secret(request, base_url=Depends(get_base_url))</code>  <code>async</code>","text":"<p>Encrypts a secret provided in the request.</p> <p>This endpoint takes a secret string and a passphrase, encrypts the secret, and returns a hash representing the encrypted data along with a URL that can be used to decrypt it.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>EncryptRequest</code> <p>An <code>EncryptRequest</code> object containing the secret to be encrypted and the passphrase to use for encryption.</p> required <code>base_url</code> <code>str</code> <p>The base URL of the application, injected as a dependency. Used to construct the decryption URL.</p> <code>Depends(get_base_url)</code> <p>Returns:</p> Type Description <code>EncryptResponse</code> <p>An <code>EncryptResponse</code> object containing the hash of the encrypted secret</p> <code>EncryptResponse</code> <p>and the full URL for decryption.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the <code>request.secret</code> cannot be UTF-8 encoded, a 400 Bad Request error is raised.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>@api.post(\"/encrypt\", response_model=EncryptResponse, tags=[\"encryption\"])\nasync def encrypt_secret(request: EncryptRequest, base_url: str = Depends(get_base_url)) -&gt; EncryptResponse:\n    \"\"\"Encrypts a secret provided in the request.\n\n    This endpoint takes a secret string and a passphrase, encrypts the secret,\n    and returns a hash representing the encrypted data along with a URL\n    that can be used to decrypt it.\n\n    Args:\n        request: An `EncryptRequest` object containing the secret to be encrypted\n            and the passphrase to use for encryption.\n        base_url: The base URL of the application, injected as a dependency.\n            Used to construct the decryption URL.\n\n    Returns:\n        An `EncryptResponse` object containing the hash of the encrypted secret\n        and the full URL for decryption.\n\n    Raises:\n        HTTPException: If the `request.secret` cannot be UTF-8 encoded,\n            a 400 Bad Request error is raised.\n    \"\"\"\n    try:\n        data = request.secret.encode(\"utf-8\")\n    except UnicodeEncodeError as e:\n        raise HTTPException(\n            status_code=400, detail=\"Invalid secret format. Only UTF-8 encoded strings are allowed.\"\n        ) from e\n\n    _, hash_value = app.encryption_service.encrypt(data, request.passphrase)\n    decrypt_url = f\"{base_url}?hash={hash_value}\"\n    return EncryptResponse(hash=hash_value, decrypt_url=decrypt_url)\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.get_base_url","title":"<code>get_base_url(request)</code>","text":"<p>Extract base URL from request.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>def get_base_url(request: Request) -&gt; str:\n    \"\"\"Extract base URL from request.\"\"\"\n    return str(request.base_url).rstrip(\"/\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.get_theme_path","title":"<code>get_theme_path(name)</code>","text":"<p>Get path to the HTML skin/theme.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>def get_theme_path(name: str) -&gt; str:\n    \"\"\"Get path to the HTML skin/theme.\"\"\"\n    filename = os.path.basename(name)\n    theme_name = filename + \".html\"\n\n    themes_dir = os.path.join(static_dir, \"themes\")\n    requested_theme_path = os.path.join(themes_dir, theme_name)\n    default_theme_path = os.path.join(themes_dir, \"default.html\")\n\n    if os.path.isfile(requested_theme_path):\n        return requested_theme_path\n\n    if os.path.isfile(default_theme_path):\n        return default_theme_path\n\n    raise HTTPException(status_code=500, detail=\"Server configuration error: Default theme file is missing.\")\n</code></pre>"},{"location":"adapters/webapi/#topsecret.adapters.webapi.root","title":"<code>root(theme=None)</code>  <code>async</code>","text":"<p>Serve the HTML frontend.</p> Source code in <code>topsecret/adapters/webapi.py</code> <pre><code>@api.get(\"/\", response_class=HTMLResponse, tags=[\"ui\"])\nasync def root(theme: str | None = None) -&gt; str:\n    \"\"\"Serve the HTML frontend.\"\"\"\n    theme = theme or \"default\"\n    html_path = get_theme_path(theme)\n    with open(html_path) as f:\n        return f.read()\n</code></pre>"},{"location":"infra/cipher/aes/","title":"AES cipher","text":"<p>AES is a symmetric encryption algorithm that is widely used for securing data. It operates on fixed-size blocks of data and uses a secret key for both encryption and decryption. AES is known for its speed and security, making it a popular choice for various applications.</p>"},{"location":"infra/cipher/aes/#topsecret.infra.cipher.aes.PKCS7AESCipher","title":"<code>PKCS7AESCipher</code>","text":"<p>               Bases: <code>CipherProtocol</code></p> Source code in <code>topsecret/infra/cipher/aes.py</code> <pre><code>class PKCS7AESCipher(CipherProtocol):\n    class MethodType(StrEnum):\n        PASSPHRASE = \"passphrase\"  # noqa: S105\n        AUTO = \"auto\"\n\n    def __init__(self, iterations: int = 100000, algorithm: hashes.HashAlgorithm | None = None):\n        self.iterations = iterations\n        self.algorithm = algorithm or hashes.SHA256()\n\n    AUTO_KEY_SEP = b\"|\"\n\n    def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Metadata]:\n        \"\"\"Encrypts the provided data using either a passphrase or an auto-generated key.\n\n        This method supports two modes of encryption:\n\n        1.  **Passphrase-based**: If a `passphrase` is provided, a key is derived\n            from it using PBKDF2HMAC. A salt is generated (or used if provided\n            internally, though this implementation always generates a new one for\n            passphrase encryption via `_get_key`) and prepended to the ciphertext.\n            The metadata will indicate `method: \"passphrase\"`.\n\n\n        2....  **Auto-generated key**: If no `passphrase` is provided, a new Fernet key\n            is generated. This key is then prepended to the ciphertext, separated\n            by a `b\"|\"` delimiter. The metadata will indicate `method: \"auto\"`.\n\n        The Fernet symmetric encryption algorithm is used for the actual encryption\n        of the data.\n\n        Args:\n            data: The bytes to be encrypted.\n            passphrase: An optional secret phrase. If provided, it's used to\n                derive the encryption key. If None, a new key is generated\n                and stored with the ciphertext.\n\n        Returns:\n            A tuple containing:\n                - Ciphertext: The encrypted data.\n                  If passphrase-based, this is `salt + encrypted_content`.\n                  If auto-key based, this is `key + b\"|\" + encrypted_content`.\n                - Metadata: A dictionary containing information about the\n                  encryption process, specifically the `method` used\n                  (\"passphrase\" or \"auto\").\n        \"\"\"\n        key, salt = _get_key(passphrase, algorithm=self.algorithm, iterations=self.iterations)\n        cipher = Fernet(key)\n        ciphertext = cipher.encrypt(data)\n\n        metadata: Metadata = {}\n        if passphrase:\n            # For passphrase-based encryption, salt must exist as _get_key generates it.\n            encrypted_data = salt + ciphertext if salt else ciphertext\n            metadata[\"method\"] = self.MethodType.PASSPHRASE\n        else:\n            # For auto-generated key encryption, prepend the key itself to the ciphertext.\n            # The key is separated from the actual ciphertext by AUTO_KEY_SEP.\n            # This allows decryption without needing external key management for this mode.\n            encrypted_data = key + self.AUTO_KEY_SEP + ciphertext\n            metadata[\"method\"] = self.MethodType.AUTO\n\n        return encrypted_data, metadata\n\n    def decrypt(self, ciphertext: Ciphertext, metadata: Metadata, passphrase: str | None = None) -&gt; str:\n        \"\"\"Decrypts the provided ciphertext using the method specified in metadata.\n\n        This method supports two modes of decryption, corresponding to the encryption\n        methods:\n        1.  **Passphrase-based**: If `metadata[\"method\"]` is \"passphrase\", this\n            method expects a `passphrase` to be provided. It extracts the salt\n            from the beginning of the `ciphertext`, derives the decryption key\n            using the passphrase and salt (via `_get_key`), and then decrypts\n            the remaining part of the `ciphertext`.\n        2.  **Auto-generated key**: If `metadata[\"method\"]` is \"auto\" (or if no\n            method is specified, \"auto\" is assumed), this method expects the\n            decryption key to be prepended to the `ciphertext`, separated by\n            `AUTO_KEY_SEP`. It splits the `ciphertext` to retrieve the key and\n            the actual encrypted data, then uses this key for decryption.\n\n        The Fernet symmetric decryption algorithm is used for the actual decryption.\n\n        Args:\n            ciphertext: The encrypted data.\n                If passphrase-based, this is `salt + encrypted_content`.\n                If auto-key based, this is `key + b\"|\" + encrypted_content`.\n            metadata: A dictionary containing information about the\n                encryption process, crucially the `method` (\"passphrase\" or \"auto\").\n            passphrase: The secret phrase used for encryption if the method was\n                \"passphrase\". Required for passphrase-based decryption.\n\n        Returns:\n            The decrypted data as a UTF-8 string.\n\n        Raises:\n            DecryptionError: If decryption fails due to various reasons,\n                such as a missing passphrase for passphrase-based decryption,\n                an invalid passphrase, an invalid key, corrupted ciphertext,\n                or an unknown encryption method.\n        \"\"\"\n        method = metadata.get(\"method\", self.MethodType.AUTO)\n        match method:\n            case self.MethodType.PASSPHRASE:\n                if passphrase is None:\n                    raise DecryptionError(\"Passphrase required for decryption.\")  # noqa: TRY003\n                # The salt is assumed to be the first 16 bytes, as generated by os.urandom(16) in _get_key.\n                salt = ciphertext[:16]\n                actual_ciphertext = ciphertext[16:]\n                key, _ = _get_key(passphrase, iterations=self.iterations, algorithm=self.algorithm, salt=salt)\n                cipher = Fernet(key)\n                try:\n                    decrypted_data = cipher.decrypt(actual_ciphertext)\n                except InvalidToken as e:\n                    raise DecryptionError(\"Invalid passphrase or corrupted data.\") from e  # noqa: TRY003\n                except KeyError as e:\n                    raise DecryptionError(\"Invalid key.\") from e  # noqa: TRY003\n\n            case self.MethodType.AUTO:\n                # In \"auto\" mode, the key is prepended to the ciphertext, separated by AUTO_KEY_SEP.\n                key_parts = ciphertext.split(self.AUTO_KEY_SEP, 1)\n                if len(key_parts) != 2:\n                    # This indicates the ciphertext is not in the expected format (key|data).\n                    raise DecryptionError(\n                        \"Invalid ciphertext format for auto mode. Expected key and data separated by '|'.\"\n                    )  # noqa: TRY003\n                key, actual_ciphertext = key_parts\n                cipher = Fernet(key)\n                try:\n                    decrypted_data = cipher.decrypt(actual_ciphertext)\n                except InvalidToken as e:\n                    # This can happen if the embedded key is incorrect or the ciphertext is corrupted.\n                    raise DecryptionError(\n                        \"Failed to decrypt the data with the auto-embedded key. The ciphertext may be corrupted.\"\n                    ) from e  # noqa: TRY003\n            case _:\n                # If the method specified in metadata is not recognized.\n                raise DecryptionError(f\"Unknown encryption method: {method}\")  # noqa: TRY003\n\n        return decrypted_data.decode(\"utf-8\")\n</code></pre>"},{"location":"infra/cipher/aes/#topsecret.infra.cipher.aes.PKCS7AESCipher.decrypt","title":"<code>decrypt(ciphertext, metadata, passphrase=None)</code>","text":"<p>Decrypts the provided ciphertext using the method specified in metadata.</p> <p>This method supports two modes of decryption, corresponding to the encryption methods: 1.  Passphrase-based: If <code>metadata[\"method\"]</code> is \"passphrase\", this     method expects a <code>passphrase</code> to be provided. It extracts the salt     from the beginning of the <code>ciphertext</code>, derives the decryption key     using the passphrase and salt (via <code>_get_key</code>), and then decrypts     the remaining part of the <code>ciphertext</code>. 2.  Auto-generated key: If <code>metadata[\"method\"]</code> is \"auto\" (or if no     method is specified, \"auto\" is assumed), this method expects the     decryption key to be prepended to the <code>ciphertext</code>, separated by     <code>AUTO_KEY_SEP</code>. It splits the <code>ciphertext</code> to retrieve the key and     the actual encrypted data, then uses this key for decryption.</p> <p>The Fernet symmetric decryption algorithm is used for the actual decryption.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>Ciphertext</code> <p>The encrypted data. If passphrase-based, this is <code>salt + encrypted_content</code>. If auto-key based, this is <code>key + b\"|\" + encrypted_content</code>.</p> required <code>metadata</code> <code>Metadata</code> <p>A dictionary containing information about the encryption process, crucially the <code>method</code> (\"passphrase\" or \"auto\").</p> required <code>passphrase</code> <code>str | None</code> <p>The secret phrase used for encryption if the method was \"passphrase\". Required for passphrase-based decryption.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The decrypted data as a UTF-8 string.</p> <p>Raises:</p> Type Description <code>DecryptionError</code> <p>If decryption fails due to various reasons, such as a missing passphrase for passphrase-based decryption, an invalid passphrase, an invalid key, corrupted ciphertext, or an unknown encryption method.</p> Source code in <code>topsecret/infra/cipher/aes.py</code> <pre><code>def decrypt(self, ciphertext: Ciphertext, metadata: Metadata, passphrase: str | None = None) -&gt; str:\n    \"\"\"Decrypts the provided ciphertext using the method specified in metadata.\n\n    This method supports two modes of decryption, corresponding to the encryption\n    methods:\n    1.  **Passphrase-based**: If `metadata[\"method\"]` is \"passphrase\", this\n        method expects a `passphrase` to be provided. It extracts the salt\n        from the beginning of the `ciphertext`, derives the decryption key\n        using the passphrase and salt (via `_get_key`), and then decrypts\n        the remaining part of the `ciphertext`.\n    2.  **Auto-generated key**: If `metadata[\"method\"]` is \"auto\" (or if no\n        method is specified, \"auto\" is assumed), this method expects the\n        decryption key to be prepended to the `ciphertext`, separated by\n        `AUTO_KEY_SEP`. It splits the `ciphertext` to retrieve the key and\n        the actual encrypted data, then uses this key for decryption.\n\n    The Fernet symmetric decryption algorithm is used for the actual decryption.\n\n    Args:\n        ciphertext: The encrypted data.\n            If passphrase-based, this is `salt + encrypted_content`.\n            If auto-key based, this is `key + b\"|\" + encrypted_content`.\n        metadata: A dictionary containing information about the\n            encryption process, crucially the `method` (\"passphrase\" or \"auto\").\n        passphrase: The secret phrase used for encryption if the method was\n            \"passphrase\". Required for passphrase-based decryption.\n\n    Returns:\n        The decrypted data as a UTF-8 string.\n\n    Raises:\n        DecryptionError: If decryption fails due to various reasons,\n            such as a missing passphrase for passphrase-based decryption,\n            an invalid passphrase, an invalid key, corrupted ciphertext,\n            or an unknown encryption method.\n    \"\"\"\n    method = metadata.get(\"method\", self.MethodType.AUTO)\n    match method:\n        case self.MethodType.PASSPHRASE:\n            if passphrase is None:\n                raise DecryptionError(\"Passphrase required for decryption.\")  # noqa: TRY003\n            # The salt is assumed to be the first 16 bytes, as generated by os.urandom(16) in _get_key.\n            salt = ciphertext[:16]\n            actual_ciphertext = ciphertext[16:]\n            key, _ = _get_key(passphrase, iterations=self.iterations, algorithm=self.algorithm, salt=salt)\n            cipher = Fernet(key)\n            try:\n                decrypted_data = cipher.decrypt(actual_ciphertext)\n            except InvalidToken as e:\n                raise DecryptionError(\"Invalid passphrase or corrupted data.\") from e  # noqa: TRY003\n            except KeyError as e:\n                raise DecryptionError(\"Invalid key.\") from e  # noqa: TRY003\n\n        case self.MethodType.AUTO:\n            # In \"auto\" mode, the key is prepended to the ciphertext, separated by AUTO_KEY_SEP.\n            key_parts = ciphertext.split(self.AUTO_KEY_SEP, 1)\n            if len(key_parts) != 2:\n                # This indicates the ciphertext is not in the expected format (key|data).\n                raise DecryptionError(\n                    \"Invalid ciphertext format for auto mode. Expected key and data separated by '|'.\"\n                )  # noqa: TRY003\n            key, actual_ciphertext = key_parts\n            cipher = Fernet(key)\n            try:\n                decrypted_data = cipher.decrypt(actual_ciphertext)\n            except InvalidToken as e:\n                # This can happen if the embedded key is incorrect or the ciphertext is corrupted.\n                raise DecryptionError(\n                    \"Failed to decrypt the data with the auto-embedded key. The ciphertext may be corrupted.\"\n                ) from e  # noqa: TRY003\n        case _:\n            # If the method specified in metadata is not recognized.\n            raise DecryptionError(f\"Unknown encryption method: {method}\")  # noqa: TRY003\n\n    return decrypted_data.decode(\"utf-8\")\n</code></pre>"},{"location":"infra/cipher/aes/#topsecret.infra.cipher.aes.PKCS7AESCipher.encrypt","title":"<code>encrypt(data, passphrase=None)</code>","text":"<p>Encrypts the provided data using either a passphrase or an auto-generated key.</p> <p>This method supports two modes of encryption:</p> <ol> <li>Passphrase-based: If a <code>passphrase</code> is provided, a key is derived     from it using PBKDF2HMAC. A salt is generated (or used if provided     internally, though this implementation always generates a new one for     passphrase encryption via <code>_get_key</code>) and prepended to the ciphertext.     The metadata will indicate <code>method: \"passphrase\"</code>.</li> </ol> <p>2....  Auto-generated key: If no <code>passphrase</code> is provided, a new Fernet key     is generated. This key is then prepended to the ciphertext, separated     by a <code>b\"|\"</code> delimiter. The metadata will indicate <code>method: \"auto\"</code>.</p> <p>The Fernet symmetric encryption algorithm is used for the actual encryption of the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The bytes to be encrypted.</p> required <code>passphrase</code> <code>str | None</code> <p>An optional secret phrase. If provided, it's used to derive the encryption key. If None, a new key is generated and stored with the ciphertext.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Ciphertext, Metadata]</code> <p>A tuple containing: - Ciphertext: The encrypted data.   If passphrase-based, this is <code>salt + encrypted_content</code>.   If auto-key based, this is <code>key + b\"|\" + encrypted_content</code>. - Metadata: A dictionary containing information about the   encryption process, specifically the <code>method</code> used   (\"passphrase\" or \"auto\").</p> Source code in <code>topsecret/infra/cipher/aes.py</code> <pre><code>def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Metadata]:\n    \"\"\"Encrypts the provided data using either a passphrase or an auto-generated key.\n\n    This method supports two modes of encryption:\n\n    1.  **Passphrase-based**: If a `passphrase` is provided, a key is derived\n        from it using PBKDF2HMAC. A salt is generated (or used if provided\n        internally, though this implementation always generates a new one for\n        passphrase encryption via `_get_key`) and prepended to the ciphertext.\n        The metadata will indicate `method: \"passphrase\"`.\n\n\n    2....  **Auto-generated key**: If no `passphrase` is provided, a new Fernet key\n        is generated. This key is then prepended to the ciphertext, separated\n        by a `b\"|\"` delimiter. The metadata will indicate `method: \"auto\"`.\n\n    The Fernet symmetric encryption algorithm is used for the actual encryption\n    of the data.\n\n    Args:\n        data: The bytes to be encrypted.\n        passphrase: An optional secret phrase. If provided, it's used to\n            derive the encryption key. If None, a new key is generated\n            and stored with the ciphertext.\n\n    Returns:\n        A tuple containing:\n            - Ciphertext: The encrypted data.\n              If passphrase-based, this is `salt + encrypted_content`.\n              If auto-key based, this is `key + b\"|\" + encrypted_content`.\n            - Metadata: A dictionary containing information about the\n              encryption process, specifically the `method` used\n              (\"passphrase\" or \"auto\").\n    \"\"\"\n    key, salt = _get_key(passphrase, algorithm=self.algorithm, iterations=self.iterations)\n    cipher = Fernet(key)\n    ciphertext = cipher.encrypt(data)\n\n    metadata: Metadata = {}\n    if passphrase:\n        # For passphrase-based encryption, salt must exist as _get_key generates it.\n        encrypted_data = salt + ciphertext if salt else ciphertext\n        metadata[\"method\"] = self.MethodType.PASSPHRASE\n    else:\n        # For auto-generated key encryption, prepend the key itself to the ciphertext.\n        # The key is separated from the actual ciphertext by AUTO_KEY_SEP.\n        # This allows decryption without needing external key management for this mode.\n        encrypted_data = key + self.AUTO_KEY_SEP + ciphertext\n        metadata[\"method\"] = self.MethodType.AUTO\n\n    return encrypted_data, metadata\n</code></pre>"},{"location":"infra/cipher/aes/#topsecret.infra.cipher.aes.get_hash","title":"<code>get_hash(data)</code>","text":"<p>Generate a SHA-256 hash of the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The bytes to hash</p> required <p>Returns:</p> Type Description <code>str</code> <p>Hexadecimal string representation of the hash</p> Source code in <code>topsecret/infra/cipher/aes.py</code> <pre><code>def get_hash(data: bytes) -&gt; str:\n    \"\"\"\n    Generate a SHA-256 hash of the provided data.\n\n    Args:\n        data: The bytes to hash\n\n    Returns:\n        Hexadecimal string representation of the hash\n    \"\"\"\n    return hashlib.sha256(data).hexdigest()\n</code></pre>"},{"location":"infra/storage/inmem/","title":"In memory (for dev)","text":"<p>In-Memory Storage is a simple key-value store that keeps data in memory. It is useful for testing and development purposes, but not suitable for production use due to its volatility.</p>"},{"location":"infra/storage/inmem/#topsecret.infra.storage.inmem.InMemStorage","title":"<code>InMemStorage</code>","text":"<p>               Bases: <code>CipherStorageProtocol</code></p> <p>An in-memory implementation of the CipherStorageProtocol.</p> <p>This class provides a simple, non-persistent storage mechanism using a Python dictionary. It is suitable for testing or scenarios where data persistence across sessions is not required.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict[Hash, tuple[Ciphertext, Metadata]]</code> <p>A dictionary to store ciphertexts and their associated metadata, keyed by a hash.</p> Source code in <code>topsecret/infra/storage/inmem.py</code> <pre><code>class InMemStorage(CipherStorageProtocol):\n    \"\"\"An in-memory implementation of the CipherStorageProtocol.\n\n    This class provides a simple, non-persistent storage mechanism using a Python\n    dictionary. It is suitable for testing or scenarios where data persistence\n    across sessions is not required.\n\n    Attributes:\n        data (dict[Hash, tuple[Ciphertext, Metadata]]): A dictionary to store\n            ciphertexts and their associated metadata, keyed by a hash.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the InMemStorage.\n\n        Sets up an empty dictionary to hold the stored data.\n        \"\"\"\n        self.data: dict[Hash, tuple[Ciphertext, Metadata]] = {}\n\n    def store(self, key: str, value: tuple[Ciphertext, Metadata]) -&gt; None:\n        \"\"\"Stores a ciphertext and its metadata associated with a key.\n\n        Args:\n            key (str): The key under which to store the value.\n            value (tuple[Ciphertext, Metadata]): A tuple containing the\n                ciphertext and its associated metadata.\n        \"\"\"\n\n        self.data[key] = value\n\n    def retrieve(self, key: Hash) -&gt; tuple[Ciphertext, Metadata]:\n        \"\"\"Retrieves the ciphertext and metadata associated with a key.\n\n        Args:\n            key (Hash): The key for which to retrieve the data.\n\n        Returns:\n            tuple[Ciphertext, Metadata]: The stored ciphertext and metadata.\n\n        Raises:\n            KeyError: If the key is not found in the storage.\n        \"\"\"\n        return self.data[key]\n\n    def contains(self, key: Hash) -&gt; bool:\n        \"\"\"Checks if a key exists in the storage.\n\n        Args:\n            key (Hash): The key to check for.\n\n        Returns:\n            bool: True if the key exists in the storage, False otherwise.\n        \"\"\"\n        return key in self.data\n</code></pre>"},{"location":"infra/storage/inmem/#topsecret.infra.storage.inmem.InMemStorage.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the InMemStorage.</p> <p>Sets up an empty dictionary to hold the stored data.</p> Source code in <code>topsecret/infra/storage/inmem.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the InMemStorage.\n\n    Sets up an empty dictionary to hold the stored data.\n    \"\"\"\n    self.data: dict[Hash, tuple[Ciphertext, Metadata]] = {}\n</code></pre>"},{"location":"infra/storage/inmem/#topsecret.infra.storage.inmem.InMemStorage.contains","title":"<code>contains(key)</code>","text":"<p>Checks if a key exists in the storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hash</code> <p>The key to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists in the storage, False otherwise.</p> Source code in <code>topsecret/infra/storage/inmem.py</code> <pre><code>def contains(self, key: Hash) -&gt; bool:\n    \"\"\"Checks if a key exists in the storage.\n\n    Args:\n        key (Hash): The key to check for.\n\n    Returns:\n        bool: True if the key exists in the storage, False otherwise.\n    \"\"\"\n    return key in self.data\n</code></pre>"},{"location":"infra/storage/inmem/#topsecret.infra.storage.inmem.InMemStorage.retrieve","title":"<code>retrieve(key)</code>","text":"<p>Retrieves the ciphertext and metadata associated with a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hash</code> <p>The key for which to retrieve the data.</p> required <p>Returns:</p> Type Description <code>tuple[Ciphertext, Metadata]</code> <p>tuple[Ciphertext, Metadata]: The stored ciphertext and metadata.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the storage.</p> Source code in <code>topsecret/infra/storage/inmem.py</code> <pre><code>def retrieve(self, key: Hash) -&gt; tuple[Ciphertext, Metadata]:\n    \"\"\"Retrieves the ciphertext and metadata associated with a key.\n\n    Args:\n        key (Hash): The key for which to retrieve the data.\n\n    Returns:\n        tuple[Ciphertext, Metadata]: The stored ciphertext and metadata.\n\n    Raises:\n        KeyError: If the key is not found in the storage.\n    \"\"\"\n    return self.data[key]\n</code></pre>"},{"location":"infra/storage/inmem/#topsecret.infra.storage.inmem.InMemStorage.store","title":"<code>store(key, value)</code>","text":"<p>Stores a ciphertext and its metadata associated with a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>tuple[Ciphertext, Metadata]</code> <p>A tuple containing the ciphertext and its associated metadata.</p> required Source code in <code>topsecret/infra/storage/inmem.py</code> <pre><code>def store(self, key: str, value: tuple[Ciphertext, Metadata]) -&gt; None:\n    \"\"\"Stores a ciphertext and its metadata associated with a key.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (tuple[Ciphertext, Metadata]): A tuple containing the\n            ciphertext and its associated metadata.\n    \"\"\"\n\n    self.data[key] = value\n</code></pre>"},{"location":"services/encryption/","title":"Encryption service","text":"<p>Encryption Service provides encryption and decryption functionality for sensitive data.</p>"},{"location":"services/encryption/#topsecret.services.encryption.EncryptionService","title":"<code>EncryptionService</code>","text":"<p>Provides encryption and decryption services.</p> <p>This class orchestrates the encryption and decryption processes, utilizing a specified cipher for cryptographic operations, a storage mechanism for persisting encrypted data, and a hash function for generating unique identifiers (keys) for stored ciphertexts.</p> <p>Attributes:</p> Name Type Description <code>cipher</code> <p>The cipher object used for encryption and decryption.</p> <code>storage</code> <p>The storage object used for storing and retrieving ciphertexts.</p> <code>hahsfn</code> <p>The hash function used to generate keys for storing ciphertexts.</p> Source code in <code>topsecret/services/encryption.py</code> <pre><code>class EncryptionService:\n    \"\"\"Provides encryption and decryption services.\n\n    This class orchestrates the encryption and decryption processes,\n    utilizing a specified cipher for cryptographic operations, a storage\n    mechanism for persisting encrypted data, and a hash function for\n    generating unique identifiers (keys) for stored ciphertexts.\n\n    Attributes:\n        cipher: The cipher object used for encryption and\n            decryption.\n        storage: The storage object used for storing\n            and retrieving ciphertexts.\n        hahsfn: The hash function used to generate\n            keys for storing ciphertexts.\n    \"\"\"\n\n    def __init__(self, cipher: CipherProtocol, storage: CipherStorageProtocol, hashfn: Callable[[bytes], str]) -&gt; None:\n        \"\"\"Initializes the instance with a cipher, storage, and hash function.\n\n        Args:\n            cipher: An object conforming to the CipherProtocol, used for\n                encryption and decryption operations.\n            storage: An object conforming to the CipherStorageProtocol, used for\n                storing and retrieving cipher-related data.\n            hashfn: A callable that takes bytes as input and returns a string\n                hash, used for hashing operations within the service.\n        \"\"\"\n        self.cipher = cipher\n        self.storage = storage\n        self.hashfn = hashfn\n\n    def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Hash]:\n        \"\"\"Encrypts the given data and stores it.\n\n        This method encrypts the input data using the configured cipher.\n        It then calculates a hash of the ciphertext and stores the\n        ciphertext along with its metadata using this hash as the key.\n\n        Args:\n            data: The byte string to be encrypted.\n            passphrase: An optional passphrase for encryption. If not\n                provided, the cipher's default or pre-configured\n                passphrase/key might be used.\n\n        Returns:\n            A tuple containing the ciphertext and its corresponding hash.\n            The first element is the encrypted data (Ciphertext), and the\n            second element is the hash (Hash) of the ciphertext.\n        \"\"\"\n        ciphertext, metadata = self.cipher.encrypt(data, passphrase)\n        hash_value = self.hashfn(ciphertext)\n        value = (ciphertext, metadata)\n        self.storage.store(key=hash_value, value=value)\n        return ciphertext, hash_value\n\n    def decrypt(self, hash_value: Hash, passphrase: str | None = None) -&gt; str:\n        \"\"\"Decrypts a ciphertext retrieved from storage using a hash value.\n\n        This method retrieves the encrypted data (ciphertext) and its associated\n        metadata from storage using the provided `hash_value`. If the entry\n        is not found, a `DecryptionError` is raised. Otherwise, it delegates\n        the decryption process to the configured cipher object using the\n        retrieved ciphertext, metadata, and the optionally provided `passphrase`.\n\n        Args:\n            hash_value (Hash): The unique identifier used to retrieve the\n                ciphertext and metadata from storage.\n            passphrase (str or None, optional): The passphrase for decryption.\n                Defaults to None. The behavior when None is provided (e.g.,\n                using a default key or requiring a passphrase explicitly if one\n                is necessary for the cipher) depends on the specific cipher\n                implementation.\n\n        Returns:\n            str: The decrypted plaintext string.\n\n        Raises:\n            DecryptionError: If no ciphertext is found in storage for the\n                given `hash_value`.\n            Exception: Propagated if the underlying `self.cipher.decrypt()`\n                method fails. This can occur for various reasons, such as an\n                incorrect passphrase, corrupted ciphertext, or other\n                cipher-specific issues.\n        \"\"\"\n        try:\n            value = self.storage.retrieve(key=hash_value)\n        except KeyError as e:\n            raise DecryptionError(\"Ciphertext not found in storage.\") from e  # noqa: TRY003\n\n        if value is None:\n            raise DecryptionError(\"Ciphertext not found in storage.\")  # noqa: TRY003\n\n        ciphertext, metadata = value\n        return self.cipher.decrypt(ciphertext, metadata, passphrase)\n</code></pre>"},{"location":"services/encryption/#topsecret.services.encryption.EncryptionService.__init__","title":"<code>__init__(cipher, storage, hashfn)</code>","text":"<p>Initializes the instance with a cipher, storage, and hash function.</p> <p>Parameters:</p> Name Type Description Default <code>cipher</code> <code>CipherProtocol</code> <p>An object conforming to the CipherProtocol, used for encryption and decryption operations.</p> required <code>storage</code> <code>CipherStorageProtocol</code> <p>An object conforming to the CipherStorageProtocol, used for storing and retrieving cipher-related data.</p> required <code>hashfn</code> <code>Callable[[bytes], str]</code> <p>A callable that takes bytes as input and returns a string hash, used for hashing operations within the service.</p> required Source code in <code>topsecret/services/encryption.py</code> <pre><code>def __init__(self, cipher: CipherProtocol, storage: CipherStorageProtocol, hashfn: Callable[[bytes], str]) -&gt; None:\n    \"\"\"Initializes the instance with a cipher, storage, and hash function.\n\n    Args:\n        cipher: An object conforming to the CipherProtocol, used for\n            encryption and decryption operations.\n        storage: An object conforming to the CipherStorageProtocol, used for\n            storing and retrieving cipher-related data.\n        hashfn: A callable that takes bytes as input and returns a string\n            hash, used for hashing operations within the service.\n    \"\"\"\n    self.cipher = cipher\n    self.storage = storage\n    self.hashfn = hashfn\n</code></pre>"},{"location":"services/encryption/#topsecret.services.encryption.EncryptionService.decrypt","title":"<code>decrypt(hash_value, passphrase=None)</code>","text":"<p>Decrypts a ciphertext retrieved from storage using a hash value.</p> <p>This method retrieves the encrypted data (ciphertext) and its associated metadata from storage using the provided <code>hash_value</code>. If the entry is not found, a <code>DecryptionError</code> is raised. Otherwise, it delegates the decryption process to the configured cipher object using the retrieved ciphertext, metadata, and the optionally provided <code>passphrase</code>.</p> <p>Parameters:</p> Name Type Description Default <code>hash_value</code> <code>Hash</code> <p>The unique identifier used to retrieve the ciphertext and metadata from storage.</p> required <code>passphrase</code> <code>str or None</code> <p>The passphrase for decryption. Defaults to None. The behavior when None is provided (e.g., using a default key or requiring a passphrase explicitly if one is necessary for the cipher) depends on the specific cipher implementation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decrypted plaintext string.</p> <p>Raises:</p> Type Description <code>DecryptionError</code> <p>If no ciphertext is found in storage for the given <code>hash_value</code>.</p> <code>Exception</code> <p>Propagated if the underlying <code>self.cipher.decrypt()</code> method fails. This can occur for various reasons, such as an incorrect passphrase, corrupted ciphertext, or other cipher-specific issues.</p> Source code in <code>topsecret/services/encryption.py</code> <pre><code>def decrypt(self, hash_value: Hash, passphrase: str | None = None) -&gt; str:\n    \"\"\"Decrypts a ciphertext retrieved from storage using a hash value.\n\n    This method retrieves the encrypted data (ciphertext) and its associated\n    metadata from storage using the provided `hash_value`. If the entry\n    is not found, a `DecryptionError` is raised. Otherwise, it delegates\n    the decryption process to the configured cipher object using the\n    retrieved ciphertext, metadata, and the optionally provided `passphrase`.\n\n    Args:\n        hash_value (Hash): The unique identifier used to retrieve the\n            ciphertext and metadata from storage.\n        passphrase (str or None, optional): The passphrase for decryption.\n            Defaults to None. The behavior when None is provided (e.g.,\n            using a default key or requiring a passphrase explicitly if one\n            is necessary for the cipher) depends on the specific cipher\n            implementation.\n\n    Returns:\n        str: The decrypted plaintext string.\n\n    Raises:\n        DecryptionError: If no ciphertext is found in storage for the\n            given `hash_value`.\n        Exception: Propagated if the underlying `self.cipher.decrypt()`\n            method fails. This can occur for various reasons, such as an\n            incorrect passphrase, corrupted ciphertext, or other\n            cipher-specific issues.\n    \"\"\"\n    try:\n        value = self.storage.retrieve(key=hash_value)\n    except KeyError as e:\n        raise DecryptionError(\"Ciphertext not found in storage.\") from e  # noqa: TRY003\n\n    if value is None:\n        raise DecryptionError(\"Ciphertext not found in storage.\")  # noqa: TRY003\n\n    ciphertext, metadata = value\n    return self.cipher.decrypt(ciphertext, metadata, passphrase)\n</code></pre>"},{"location":"services/encryption/#topsecret.services.encryption.EncryptionService.encrypt","title":"<code>encrypt(data, passphrase=None)</code>","text":"<p>Encrypts the given data and stores it.</p> <p>This method encrypts the input data using the configured cipher. It then calculates a hash of the ciphertext and stores the ciphertext along with its metadata using this hash as the key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The byte string to be encrypted.</p> required <code>passphrase</code> <code>str | None</code> <p>An optional passphrase for encryption. If not provided, the cipher's default or pre-configured passphrase/key might be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Ciphertext</code> <p>A tuple containing the ciphertext and its corresponding hash.</p> <code>Hash</code> <p>The first element is the encrypted data (Ciphertext), and the</p> <code>tuple[Ciphertext, Hash]</code> <p>second element is the hash (Hash) of the ciphertext.</p> Source code in <code>topsecret/services/encryption.py</code> <pre><code>def encrypt(self, data: bytes, passphrase: str | None = None) -&gt; tuple[Ciphertext, Hash]:\n    \"\"\"Encrypts the given data and stores it.\n\n    This method encrypts the input data using the configured cipher.\n    It then calculates a hash of the ciphertext and stores the\n    ciphertext along with its metadata using this hash as the key.\n\n    Args:\n        data: The byte string to be encrypted.\n        passphrase: An optional passphrase for encryption. If not\n            provided, the cipher's default or pre-configured\n            passphrase/key might be used.\n\n    Returns:\n        A tuple containing the ciphertext and its corresponding hash.\n        The first element is the encrypted data (Ciphertext), and the\n        second element is the hash (Hash) of the ciphertext.\n    \"\"\"\n    ciphertext, metadata = self.cipher.encrypt(data, passphrase)\n    hash_value = self.hashfn(ciphertext)\n    value = (ciphertext, metadata)\n    self.storage.store(key=hash_value, value=value)\n    return ciphertext, hash_value\n</code></pre>"}]}